\chapter{COMMON commands}
\section{News}
\par
Here you find a list of recent changes, additions, bug corrections 
\subsection*{2018\_September}
\par
Modified the do and if constructions to be valid as well for 
"end do" "end if" and "else if" with arbitrary blanks. 
\subsection*{2018\_July}
\par
Modified the ==$> $ 'fput' and 'fget' commands to take an optional 
    format string 
\par
Modified the ==$> $ 'system' command to be a bit more flexible 
\par
Modified the ==$> $ function "fmodt" to take a file name as well. 
\subsection*{2018\_June}
\par
Revised the reaction to a CTRL-C 
\par
Added a ==$> $ 'set wait $ \{$"on"$| $"off"$\} $ option 
\par
Added a ==$> $ 'set error, ... , "save" option 
\subsection*{2018\_May}
\par
The variables ==$> $ 'variable' were augmented by 1-D and 2-D arrays. 
New commands ==$> $ 'matmul', 'matadd','invmat', 'mattrans', 
'detmat' provide the usual arithmetics 
\subsection*{2018\_Feb}
\par
New read-only ==$> $ variables "PROGRAM", "STATE", "MPI", "MPI\_FIRST" 
were introduced that can be querried to learn in which program 
section and at what state you are. 
\par
As a patch to overcome internal precision, the ==$> $ 'seed' command 
can take an alternative form. 
\subsection*{2018\_Jan}
\par
The logical comparisons may now take the operators: 
$ <$, $ <$=, ==, /=, $> $=, $> $/ 
The classical fortran77 operators are still valid 
\par
New logical functions "isvar" and "isexp" can be used within an 
"if" construction. See help entry ==$> $'function' 
\par
New parameters "reset" and "delete" have been added to the 
==$> $ 'variable' command 
\subsection*{2017\_November}
\par
A 'manual' command has been added that reads the manual files 
\subsection*{2017\_Sep}
\par
Throughout the program the internal calculation of random numbers 
was changed to the FORTRAN 90 intrinsic function. 
\subsection*{2017\_July}
\par
Predefined variables REF\_* are now read/write. See ==$> $ variable 
\par
Introduced new intrinsic character functions: index and length 
See help under functions for details. 
\subsection*{2016\_October}
\par
New system variables have been introduced. They can be used like any 
other user defined variable. System variables are in capital letters. 
\subsection*{2014November}
\par
A new random number "gskew" has been added, which returns a 
Gaussian distributed random number. The underlying distribution 
can be set to be is left or right skewed. 
\section{Options}
{\bf program [-debug] [-remote] [-port=p] [-access=ip] [macro.mac] \par }
{\bf program -macro $ <$macro.mac$> $[ $ <$par1$> $ [ $ <$par2$> $ ...]] \par }
\par
\vspace{3pt}
All programs allow the following command line parameters. The flag 
"-debug" starts the program in debug mode. This is the same as using 
the command "set debug,on". The switch "-remote" starts the program 
in remote control mode. In this case the commands are send to the 
program through a socket. In this case the switch "-port' allows one 
to specify the port, the program will be listening on. Port numbers 
should be larger than 1024. The switch "-access' allows one to specify 
from which host connections will be accepted. The default is 
'localhost'. 
\par
See file "remote.f" for an example how to remote control the 
applications from another program. Note that the program will not 
accept input from the keyboard when in remote control mode. 
\par
All other command line arguments are interpreted as macro files 
and will be executed at startup. These macros may not rely on 
parameters to be given on the command line. 
\par
If a macro is to be executed that takes 1 or more parameters, use 
the "-macro" option. Note that this option is mutually exclusive 
to all other options. The first command line argument after  the 
'-macro' option it the macro name, all further optional command 
line arguments are taken as macro parameters. These have to be 
seperated by one or more spaces. 
Parameters that need to contain spaces must be enclosed in single 
or double quotation marks. 
-macro test.mac 1 2 3 
This is the same as @test.mac 1,2,3 
\par
-macro test1.mac '1 + 2 + 3' 
This is the same as @test1.mac 1 + 2 + 3 
\section{\#}
{\bf \#$ <$comment$> $ \par }
\par
\vspace{3pt}
Any line beginning with a "\#" is regarded as comment. 
\section{@}
{\bf @$ <$filename$> $ [$ <$argument$> $ ...] \par }
\par
\vspace{3pt}
Any list of valid commands can be written to an ASCII file and 
and indirectly by the command: 
\par
\begin{MacVerbatim}
prompt > @<name>
\end{MacVerbatim}
The commands may start in with leading blanks to help readability of 
the macro file. The commands are executed as typed. 
Macro files may call other macro files. This is not a call in 
the sense of calling a function. 
All variables are identical at all levels of macro file nesting. 
\par
Macro files can be written by any editor on your 
system or be generated by the ==$> $ 'learn' command. 'learn' starts to 
remember all the commands that follow and saves them into the file 
given on the 'learn' command. The learn sequence is terminated by 
the 'lend' command. The default extension is ".mac" 
\par
Optionally arguments can be listed on the command line. These arguments 
will replace the formal parameters inside the macro. The formal 
parameters must be given as "\$1", "\$2" ... The string $ <$argument$> $ will 
replace the string "\$1". "\$1" is the first argument on the command line, 
"\$2" the second and so on. If there are not enough command line arguments, 
an error message is displayed. 
The parameter "\$0" contains the number of parameters listed on the line 
that called the macro. If no parameters were given this value will be 
zero. 
\par
The prompt setting ==$> $ 'set prompt,"redirect"' has an important side 
effect on macro treatment. 
With the "redirect" setting, macros are stored internally, 
once they have been read from disk, and will be reused from memory. This 
helps to reduce unnecessary I/O, especially when you have nested macros 
inside loops. As a side effect, if a macro is modified on the disk, 
a further "@macro.mac" will not read the modified version but will 
continue to use the internaly stored version. 
\par
For all other settings, the internal macro storage is 
cleared when you get back to the normal interactive mode. This allows 
you to run a macro, then modify the version stored on the disk and 
execute the modified/corrected version. 
\section{=}
{\bf $ <$variable$> $ = $ <$expression$> $ \par }
\par
\vspace{3pt}
The expression on the right of the equal sign is evaluated and its result 
stored in variable $ <$variable$> $. 
\section{input}
{\bf Input editing functions \par }
\par
\vspace{3pt}
If the program was compiled with -DREADLINE, the following basic 
editing functions are available at the program prompt: 
\par
\begin{MacVerbatim}
  ^A               : moves to the beginning of the line
  ^B               : moves back a single character
  ^E               : moves to the end of the line
  ^F               : moves forward a single character
  ^K               : kills from current position to the end of line
  ^P or arrow up   : moves back through history
  ^N or arrow down : moves forward through history
  ^H and DEL       : delete the previous character
  ^D               : deletes the current character
  ^L/^R            : redraw line in case it gets trashed
  ^U               : kills the entire line
  ^W               : kills last word
\end{MacVerbatim}
Furthermore you can move within the line using the arrow keys. 
\par
{\bf NOTE: \par }
\par
\vspace{3pt}
If you redirect the input for executed PROG using 'prog $ <$ infile' you 
MUST use the command 'set prompt,off' or 'set prompt,redirect' in 
the first line to avoid that the program 'hangs' at the end of the 
file. (-$> $ set prompt) 
\section{break}
{\bf break $ <$levels$> $ \par }
\par
\vspace{3pt}
The 'break' command stops the execution of the current block structure 
and advances to the next command following the block structure. 
With $ <$levels$> $ equal to 1 only the current block structure is interrupted, 
with any higher number the $ <$levels$> $ innermost block structures are 
interrupted. The 'break' command can be used only inside a block structure. 
\section{cd}
{\bf cd [$ <$directory$> $] \par }
\par
\vspace{3pt}
This command allows one to change the current working directory 
(may not be available everywhere). If the command is called with 
no parameters, the current working directory is shown. 
\par
For the Windows versions, two different styles help to copy the 
folder name into the program window. 
\par
For KUPLOT and the DISCUS\_SUITE type 
cd 
and a space. Do not hit the enter/return key at this moment. 
Within a Windos Explorer click on the folder icon and copy the 
string CTRL-c. Activate the KUPLOT or DISCUS\_SUITE program and 
click the middle mouse button. This should paste the full path 
to the folder into the KUPLOT or DISCUS\_SUITE window. 
\par
For DISCUS, DIFFEV, and MIXSCAT type "cd " with the space as well. 
Now left click and drag the selected folder icon into the program 
window. This should copy the full pathinto the program window. 
Activate the window and hit the ENTER key. 
\section{continue}
{\bf continue [ "prog" ] \par }
\par
\vspace{3pt}
This command is effective only while PROG is in the interrupted 
macro mode or inside interrupted do-loop or if-statements, which serves 
as a debug mode for lengthy macros or block structures 
Make sure you have returned to the same sub menu before you continue! 
\par
Without parameters PROG resumes the execution of a macro or block 
structure in the line following the 'stop' command. If you 
had started another macro while debugging a macro, and this new macro 
contained a 'stop' command as well, the 'continue' command will run 
the remaining lines in the new macro and then stop again at the position 
of the 'stop' command in the outer macro. 
\par
By providing the 'prog' parameter, PROG immediately interrupts all 
macros and returns to the normal prompt. 
If you are in one of the sub sections "discus", "diffev", "kuplot", 
you can continue either with this subsection or go back to the main 
suite if you enter the program name as "suite". 
\section{do}
Loops can be programmed with the 'do' command. The command may take 
the  following forms: 
\begin{MacVerbatim}
do <variable> = <start>,<end> [,<increment>]
  <commands to be repeated>
enddo
\end{MacVerbatim}
Here loops may contain constants or arithmetic expressions 
for $ <$start$> $, $ <$end$> $, and $ <$increment$> $. The internal type of the 
variables is real. The loop counter is evaluated from 
($ <$end$> $ - $ <$start$> $) / $ <$increment$> $ =1 . If this is negative, the loop 
is not executed at all. 
\par
\begin{MacVerbatim}
do while (<logical expression>)
  <commands to be repeated>
enddo
\end{MacVerbatim}
These loops are executed while $ <$logical expression$> $ is true. 
Thus, they may not be executed at all. 
\begin{MacVerbatim}
do
  <commands to be repeated>
enddo until (<logical expression>)
\end{MacVerbatim}
These loops, however, are always executed once, and repeated 
until $ <$logical expression$> $ is true. 
If an error occurs during execution of the loop, the loop is 
interrupted. 
\par
As of version 5.25.1 and later, the word "enddo" 
may also be spelled "end do", where the number of blanks 
that follow the "end" is not significant. 
\section{echo}
\begin{MacVerbatim}
echo [<string>]
echo ["string%dstring",<integer expression>]
echo ["string%Dstring",<integer expression>]
echo ["string%fstring",<float expression>]
echo ["string%Fstring",<float expression>]
echo ["string%cstring",<character expression>]
\end{MacVerbatim}
The string $ <$string$> $ is echoed to the default output device as typed. 
This command serves as a marker inside long macro files. It gives the 
user a chance to include easy to find messages in order to follow 
lengthy or nested structures. 
\par
The alternative command format allows to echo formatted strings to the 
screen. Each "\%d" is replaced by the value of the corresponding 
parameter. The sequence of "\%d" corresponds to the sequence of the 
integer parameters, "\%f" stands for parameters of the type real. 
\par
The value of a numerical expression between the "\%" and the "d" 
determines the width of the integer field that is printed. 
In the case of a floating variable two expressions separated by 
a decimal point specify the width and the number of decimal 
digits that are printed. 
\par
The capital forms "\%D" and "\%F" will fill leading spaces with zeros. 
\par
A character format descriptor "\%c" or "\%Nc", with N an integer 
number, describes a string of characters. 
\par
\begin{MacVerbatim}
Examples
echo ">%3d<",44            produces :  > 44<
echo ">%1+2d<",44          produces :  > 44<
echo ">%3D<",44            produces :  >044<
echo ">%5.1f<",44.1        produces :  > 44.1<
echo ">%2**2+1.1f<",44.1   produces :  > 44.1<
echo ">%c<",'bla'          produces :  >bla<
echo ">%5c<",'bla'         produces :  >bla  <
\end{MacVerbatim}
\section{eval}
{\bf eval $ <$expr$> $ [, $ <$expr$> $ ...] \par }
\par
\vspace{3pt}
Evaluates the expression(s) and displays the result(s). The result is not 
stored, this command is for interactive display only. 
\section{exit}
{\bf exit \par }
\par
\vspace{3pt}
Terminates the program and gets you back to your shell. 
\section{expressions}
\par
Arithmetic expressions can be evaluated in a FORTRAN style. 
Character expressions are used to assign a string of characters to 
a variable or filename. 
\par
\subsection*{Arithmetic expressions:}
\par
Five basic operators are defined: 
\par
\begin{MacVerbatim}
"+"  Addition
"-"  Subtraction
"*"  Multiplication
"/"  Division
"**" Exponentiation
\end{MacVerbatim}
The usual hierarchy of operators holds. 
The parts of the expression can be grouped with parentheses "(",")" in 
order to circumvent the standard hierarchy 
Several intrinsic functions have been defined, see "functions" for a 
full listing. 
\par
Examples of valid expressions are: 
\par
\begin{MacVerbatim}
1
1+3*(sin(3.14*r[1]))
x[1]*0.155
asind(0.5)
\end{MacVerbatim}
\subsection*{Character expressions}
\par
A character expression is signaled by a pair of " ". The content may 
be a just a simple string of characters or additional format 
specifiers that are replaced by the value of a variable. 
\par
\begin{MacVerbatim}
variable character,string
variable character,line
string = "abcdefgh"
line   = "%4c",string(2:5)
line   = "%c %c",string(1:2),string(7:8)
line   = "Number: %3d",4
line   = "Number: %3.1f",4.1
line   = string          ! Both commands work,
line   = "%c",string     ! this is the prefered style
line   = "%c",fdate(0)   ! See ==> functions for a list of
\end{MacVerbatim}
                         ! character functions 
Within an ==$> $ 'if' construction you may also specify a character 
expression in the form: 
\par
\begin{MacVerbatim}
if( '"%2c",string(3:4)' .eq. 'cd' ) then
\end{MacVerbatim}
An expression (M:N) refers to the substring from the M's to the N's 
character. 
\par
\subsection*{Format specifiers}
\par
In filenames ==$> $"filename" or character expressions format specifiers 
are used to write the value of numerical or character variables into 
the corresponding string. These format specifiers may be: 
\par
\begin{MacVerbatim}
%d      writes a decimal/integer number, the number of digits
        depends on the numerical value of the number
%D      writes a decimal/integer number, the number of digits
        depends on the numerical value of the number
%3d     writes a decimal/integer number that fills 3 digits
%3D     writes a decimal/integer number that fills 3 digits,
        leading blanks are filled with zeros
        Any width larger than the number of digits required is allowed
%Md     writes a string M digits wide. M may be omitted.
        M may be an integer expression.
        d or D are allowed, D give leading zeros
%f      A floating/real number is written flushed left into a
        character string of 8 digits
%F      A floating/real number is written flushed left into a
        character string of 8 digits
%12.3f  A floating/real number is written flushed right into a
        character string of 12 digits. 3 digits are used for the
        fractional part.
%12.3F  A floating/real number is written flushed right into a
        character string of 12 digits. 3 digits are used for the
        fractional part. Leading blanks are filled by zeros.
%M.Nf   writes a string M digits wide. N may be omitted.
        M and N may be integer expressions.
        f or F are allowed, F give leading zeros
%c      A character string is written, the width depends on the input
        variable
%5c     A character string of 5 characters is written.
\end{MacVerbatim}
Examples 
\par
\begin{MacVerbatim}
variable character,string
variable character,line
string = "abcdefgh"
line   = "%c",string     ==> "abcdefgh"
line   = "%4c",string(1:4)     ==> "abcd"
line   = "Hallo %c",string(2:4)    ==> "Hallo bcd"
line   = "Number %5d",1234         ==> "Number  1234"
line   = "Number %5D",1234         ==> "Number 01234"
line   = "Float  %8.3f",3.1415     ==> "Float     3.141"
line   = "Float  %8.3F",3.1415     ==> "Float  0003.141"
\end{MacVerbatim}
\section{filenames}
Usually, file names are understood as typed, including capital 
letters. Unix operating systems distinguish between upper and lower 
case typing ! 
\par
Additionally (integer) numerical input can be written into the 
filename. The syntax for this is: 
\par
\begin{MacVerbatim}
"string%dstring",<integer expression>
"string%fstring",<real expression>
"string%cstring",<character expression>
\end{MacVerbatim}
The file format MUST be enclosed in quotation marks. The position of 
each integer must be characterized by a "\%d". The sequence of strings 
and "\%d"'s can be mixed at will. The corresponding integer expressions 
must follow after the closing quotation mark. If the command line 
requires further parameters (like "addfile" for example) they must 
be given after the format-parameters. 
The interpretation of the "\%d"'s follows the C syntax. Up to 10 numbers 
can be written into a filename. 
\par
Refer to the help entry "expressions" for further help. 
\par
Examples: 
\begin{MacVerbatim}
1)
i[5]=1
outfile a1.1
outfile "a%d.%d",1,1
outfile "a%d.%d",4-3,i[5]
outfile "a%1.1f",1.1
\end{MacVerbatim}
All the above examples will result in the file name "a1.1". 
\par
\begin{MacVerbatim}
2)
do i[1]=1,11
...
outfile "data%d.calc",i[1]
...
enddo
\end{MacVerbatim}
The output is written to the files "data1.calc" through "data11.calc" 
\section{fclose}
{\bf fclose $ \{$$ <$number$> $$| $"all"$\} $ \par }
\par
\vspace{3pt}
This command closes a file that was opened with 'fopen $ <$number$> $' or 
closes all open files. If this 
command is not used before exiting the program, data might be lost ! 
\section{fend}
{\bf fend $ <$number$> $,$ \{$'continue'$| $'error'$\} $ \par }
\par
\vspace{3pt}
This command determines the reaction to an unexpected end of file 
while reading data from input file $ <$number$> $. 
If the parameter is set to "continue", the program will set the variable 
res[0] to -1 and continue the macro. If you repeat the  ==$> $ 'fget' 
command, the program will again set res[0] to -1 and will not result 
in an error. In order to catch and EOF, you have to evaluate the 
value of res[0] each time the 'fget' command is executed. 
\par
If the parameter is set to "error", the program will stop reading 
data from the input file and terminate the macro with an error 
message. The value of res[0] remains undefined. 
\par
The default condition at program start is "error" 
\section{fexist}
{\bf fexist $ <$file$> $ \par }
\par
\vspace{3pt}
This command checks the existence of the specified file $ <$file$> $. The 
result is written on the screen and returned via the res[] variables. 
If the file exists, res[1] is 1, otherwise it is 0. The variable 
res[0] returns the number of parameters, here 1. 
\section{fformat}
{\bf fformat $ <$nc$> $,$ <$format$> $ \par }
\par
\vspace{3pt}
This command allows one to specify a FORTRAN style format string 
$ <$format$> $ to be used for column $ <$nc$> $. The default is free format, 
which can be selected using the character * as format string. If 
the command is called with no parameters, the current settings are 
displayed on the screen. Note that an unsuitable format might 
result in a conversion error and *** being written to the file ! 
\par
\begin{MacVerbatim}
Example: fform 1,F7.3
\end{MacVerbatim}
\section{fget}
{\bf fget $ <$number$> $,$ <$p1$> $,$ <$p2$> $,.. \par }
{\bf               [, form:'$ <$string$> $'] \par }
\par
\vspace{3pt}
This command allows the user to read data from a file that had been 
opened with 'fopen $ <$number$> $. If no parameters are given, a line is 
read, yet its content is ignored and the line gets skipped. 
Otherwise the read numbers will overwrite the contents of the 
specified variables. 
The values in the input file must be separated by a blank or a comma. 
This means that to read a set of words in "This is a sentence", you 
will have to read this into 4 character variables. 
\par
Note that a 'fget' command that does not run into an unexpected 
end of file sets the value of res[0] to zero! 
\par
The optional format string allows to specify an input format. 
The format string has to specify the format for each input parameter. 
It thus takes a comma delimited list of Fortran style descriptors: 
i$ <$length$> $         Integer = Whole number 
                  As in "i4"  or "i17" 
f$ <$length$> $.$ <$dec$> $   Floating point number: 
                  As in "f8.3". Only the overall length $ <$length$> $ 
                                is relevant, the length of the 
                                digits after a decimal point is ignored. 
                                Thus, other than in Fortran you 
                                can write: 
f$ <$length$> $         As in "f8" or "f12" 
a$ <$length$> $         Character = alphanumeric string 
                  As in "a20" 
\par
Example: 
Assume a file "example.text" with the following content: 
\par
3.1415  123456 
2.7182817 Hello 654321 
This is a sentence 
\par
This can be read with the following instructions 
\par
fopen 1, example.text 
variable character, str\_a 
variable character, str\_b ! formats are optional for line 1, and 2 
fget 1, r[2],i[2]         , form:'f6,i8' 
fget 1, r[2],str\_a,i[2]   , form:'f9.7,a5,i7' 
fget 1, str\_b             , form:'a18'        ! whole string is read 
fclose 1 
\section{fopen}
{\bf fopen $ <$number$> $,$ <$file$> $ [,$ \{$"append" $| $ "overwrite"$\} $] \par }
\par
\vspace{3pt}
This command allows the user to open a file for reading and writing 
using the commands 'fget' and 'fput'. The first argument is the number 
of the io\_stream. You can open several files at once, the exact value 
depends on the value of the variable MAC\_MAX\_IO in file "macro.inc". 
The second argument is the file name. The default is that existing 
files will be overwritten if 'fput' is used. Alternatively one can 
append data to a file by specifying the optional parameter "append". 
\section{fput}
{\bf fput $ <$number$> $,$ <$p1$> $,$ <$p2$> $, .. \par }
{\bf               [, form:'$ <$string$> $'] \par }
\par
\vspace{3pt}
This command allows one to write data to the file that had been opened 
by 'fopen $ <$number$> $'. The parameters $ <$pi$> $ can either be variables and 
expressions or simple text enclosed in single quotes. If no parameters 
are given, an empty line is written. 
In order to mix character variables or character functions and numbers, 
the first parameter must be a format descriptor in double "". 
\par
The optional format string allows to specify an output format. 
The format string has to specify the format for each input parameter. 
It thus takes a comma delimited list of Fortran style descriptors: 
i$ <$length$> $         Integer = Whole number 
                  As in "i4"  or "i17" 
f$ <$length$> $.$ <$dec$> $   Floating point number: 
                  As in "f8.3". Total width is 8 digits with 3 
                                digits after a decimal point. 
a$ <$length$> $         Character = alphanumeric string 
                  As in "a20" 
\par
The optional format string effectively replaces the 
==$> $ 'fformat' command. 
\par
\begin{MacVerbatim}
Examples:  fput 1, i[1],sqrt(1.0+i[1]*0.01)
           fput 1, 'Current value of i[1] : ',i[1]
           fput 1, "%c %d",'Current value of i[1] : ',i[1]
           fput 1, "%c",fdate(0)
           fput 1, 1,2,3, form:'i3,i3,i3'
           fput 1, 1,3.1415,3, form:'i3,f8.4,i3'
\end{MacVerbatim}
\section{fsub}
{\bf fsub $ <$number$> $,[$ <$left$> $,$ <$right$> $] \par }
\par
\vspace{3pt}
The command allows you to limit the string from which 'fget' reads the 
data from file $ <$number$> $. Data will only be read columns $ <$left$> $ to $ <$right$> $. 
If both parameters are missing, the full input string is read. 
If the parameter $ <$right$> $ is set to "-1", the string is read from $ <$left$> $ 
all the way to the end of the input string, independent of its length. 
\par
The default values at program start are 1,-1 for all input channels. 
\par
\begin{MacVerbatim}
Examples:
  Input line: "A text string 20.0  30.0"
  fsub 14,24
  fget r[1],r[2]
\end{MacVerbatim}
\section{functions}
\par
The following intrinsic numerical functions exist: 
\par
\begin{MacVerbatim}
asin(<arg>)                     !
acos(<arg>)                     !
atan(<arg>)                     !
atan(<arg1>,<arg2>)             ! Arguments are sine and cosine of angle
asind(<arg>)                    ! Result in degrees
acosd(<arg>)                    ! Result in degrees
atand(<arg>)                    ! Result in degrees
atand(<arg1>,<arg2>)            ! Arguments are sine and cosine of angle
sin(<arg>)                      !
cos(<arg>)                      !
tan(<arg>)                      !
sind(<arg>)                     ! Argument in degrees
cosd(<arg>)                     ! Argument in degrees
tand(<arg>)                     ! Argument in degrees
sinh(<arg>)                     ! Hyperbolic functions
cosh(<arg>)                     !
tanh(<arg>)                     !
sqrt(<arg>)                     ! Square root of <arg>
exp(<arg>)                      ! exponential (base e)
ln(<arg>)                       ! natural logarithm of <arg>
abs(<arg>)                      ! Absolute value of <arg>
mod(<arg1>,<arg2>)              ! Modulo <arg1> of <arg2>, real arguments
max(<arg1>,<arg2>)              ! Maximum of <arg1> and <arg2>
min(<arg1>,<arg2>)              ! Minimum of <arg1> and <arg2>
int(<arg>)                      ! Convert argument to integer
nint(<arg>)                     ! Convert argument to nearest integer
frac(<arg>)                     ! Returns fractional part of <arg>
ran(<arg>)                      ! Returns uniformly distributed pseudo
                                  random value 0<= r < 1.
gran(<arg>{,"s"|"f"})           ! Returns gaussian distributed pseudo
                                  random value with mean 0.0 and
                                  sigma <arg> or FWHM <arg> if the
                                  second argument is equal to "f".
gskew(<arg>,<skew>{,"s"|"f"})   ! Returns gaussian distributed pseudo
                                  random value with mean 0.0 and
                                  sigma <arg> or FWHM <arg> if the
                                  second argument is equal to "f".
                                  If skew is 0 the distribution is symmetric
                                  For skew <=  1.0 it is right skewed
                                  For skew >= -1.0 it is left  skewed
logn(<arg1>,<arg2>{,"s"|"f"})   ! Returns lognormal distributed pseudo
                                  random value. <arg1> is the location
                                  of the most likely value.
                                  <arg2> is the width of the distribution.
                                  More accurately, <arg2> is the width of
                                  the underlying distribution ln(logn).
                                  It is either sigma <arg2> or FWHM <arg2>
                                  if the third argument is equal to "f".
pois(<arg>)                     ! Returns Poisson  distributed pseudo
                                  random value with mean <arg>.
\end{MacVerbatim}
The arguments to any of these functions are any arithmetic expression. 
\par
System functions: 
\par
\begin{MacVerbatim}
date(0)                         ! Returns the current date as character
                                  string in the format:
                                  CCYYMMDDhhmmss.sss
                                  CCYY  : year    (century, year)
                                  MM    : month   (1,2,... 12)
                                  DD    : day     (1,2,... 31)
                                  hh    : hour    (1,2,... 24)
                                  mm    : minute  (1,2,... 60)
                                  ss.sss: second.milliseconds
                                  (g77: milliseconds are 000)
fdate(0)                        ! Returns the current date as character
                                  string in the format:
                                  Day Mon DD hh:mm:ss CCYY
                                  Day   : weekday (Mon, Tue,... Sun)
                                  Mon   : month   (Jan, Mar,... Dec)
                                  DD    : day     (1,2,... 31)
                                  hh    : hour    (1,2,... 24)
                                  mm    : minute  (1,2,... 60)
                                  ss    : second  (1,2,... 60)
                                  CCYY  : year    (century, year)
fmodt(0)                        ! Returns modification date and time
                                ! of the last file that was opened by
                                ! the Discus_suite.
fmodt('name')                   ! Date for file "name"
fmodt(<line>)                   ! Date for file in variable <line>
                                ! The format ! is the same as for fdate(0)
getcwd(0)                       ! Returns the current directory as
                                  character string.
getenv('name')                  ! Returns the value of the environment
                                  variable "name".
getenv(<line>)                  ! Returns the value of the environment
                                  variable that is stored in variable <line>.
index(<line>, <substring> [,"BACK"]) ! Returns the location of the
                                  substring within the line.
                                  If the optional keyword "BACK" is present,
                                  index returns the last occurence.
                                  Both, the line and the substrings may be
                                  given as simple strings in single quotations
                                  or as a variable with with a preceeding
                                  format specifier, Examples:
                                  line ='Discus'
                                  index('Discus','s')
                                  index('Discus','s', BACK)
                                  index("%",'Discus',"%",'s')
                                  index("%",line    ,"%",'s')
                                  index("%c",getcwd(0), '/')
length(<line>)                    !Returns the length of string <line>
                                  The line may be
                                  given as simple strings in single quotations
                                  or as a variable with with a preceeding
                                  format specifier, Examples:
                                  length('Discus')
                                  length("%c",line)
                                  index("%c",getcwd(0), '/')
isvar('string')                   Returns TRUE if the string is a used
                                  defined variable. Can only be used inside
                                  an if construction:
                                  Examples:
                                  if(isvar('name')) then
                                  if(isvar('$1')) then
isexp('string')                   Returns TRUE if the string is a valid
                                  expression. Can only be used inside
                                  an if construction:
                                  Examples:
                                  if(isexp('3+5.')) then
                                  if(isexp('$1')) then
\end{MacVerbatim}
\section{help}
{\bf help [$ <$command$> $ [, $ <$subcommand$> $] ] \par }
\par
\vspace{3pt}
The 'help' command is used to display on-line help messages. They are 
short notes on the command $ <$command$> $. The command may be abbreviated. 
If the abbreviation is not unique, only the first help topic that matches 
the command is listed. 
\par
The first line of the help text gives the syntax of the command that is 
explained in the following lines. For a few commands the syntax line is 
repeated for different set of possible parameters. 
\par
After the text is displayed, you are in the HELP sublevel of PROG 
and there are the following commands possible: 
\par
\begin{MacVerbatim}
<command> : Display help for <command> of current help level.
".."      : Go up one help level.
"?"       : Prints list of help entries of the current level.
<RETURN>  : Exit help sublevel.
\end{MacVerbatim}
\section{if}
The if-control structure takes the following form: 
\par
\begin{MacVerbatim}
if ( <logical expression> ) then
  <conditional commands>
[elseif ( <logical expression>) then
  <conditional commands>]
[else
  <conditional commands>]
endif
\end{MacVerbatim}
The logical expressions may contain numerical comparisons with syntax: 
\par
As of version 5.25.1 and later, the words "elseif" and "endif" 
may also be spelled "else if" or "end if", where the number of blanks 
that follow the "end" is not significant. 
\par
\begin{MacVerbatim}
<arithmetic expression> <operator> <arithmetic comparison>
\end{MacVerbatim}
The following operators are allowed: 
\par
\begin{MacVerbatim}
 <      ! less than
 <=     ! less or equal
 >      ! greater than
 >=     ! greater or equal
 ==     ! equal
 /=     ! not equal
\end{MacVerbatim}
The older forms are still valid: 
\begin{MacVerbatim}
.lt.    ! less than
.le.    ! less or equal
.gt.    ! greater than
.ge.    ! greater or equal
.eq.    ! equal
.ne.    ! not equal
\end{MacVerbatim}
The logical expressions may also contain string comparisons with syntax: 
\par
\begin{MacVerbatim}
'<string1>' <operator> '<string2>'
\end{MacVerbatim}
Both strings MUST be enclosed by single apostrophes '. The operators 
are the same as those for the numeric expressions, lexical comparisons 
are used to evaluate the comparisons "less" and "greater". 
Within the single apostrophes you can place a character replacement 
operation. Thus a valid example would be: 
variable character, line 
line='text' 
if( '"\%c",line' .eq. 'text' ) then 
\par
Logical expressions can be combined by logical operators: 
\par
\begin{MacVerbatim}
.not.   ! negation of the following expression
.and.   ! logical and
.eqv.   ! logical equivalent
.xor.   ! logical exclusive or
.or.    ! logical or
\end{MacVerbatim}
Logical operations may be nested and grouped by brackets "(" and ")". 
\section{learn}
{\bf learn [$ <$name$> $] \par }
\par
\vspace{3pt}
Starts a learn sequence. All following commands are saved as typed 
in file $ <$name$> $. defaults to "$ <$prog$> $.mac". ==$> $ lend finishes the 
learn sequence. 
\section{lend}
{\bf lend \par }
\par
\vspace{3pt}
Finishes the learn sequence started by ==$> $ learn. 
\section{manual}
{\bf manual ["section:"$ \{$"suite"  $| $ "discus"  $| $ "diffev" $| $ \par }
{\bf                    "kuplot" $| $ "package" $| $ "mixscat"$\} $ \par }
{\bf        [,"viewer:"$ <$name$> $] \par }
\par
\vspace{3pt}
Opens a PDF viewer for one of the Manuals 
\par
The section defaults to the current program section that you are 
working with. 
On Linux systems, the viewer defaults to "qpdfview", on Windows 
system it defaults to "firefox". If DISCUS does not find the 
default or the user provided viewer, DISCUS will search 
a list of common PDF viewers. If none is found an error message 
points to the folder that contains the manuals. 
\section{seed}
{\bf seed [ $ <$value$> $ ] \par }
{\bf seed [ $ <$value\_a$> $, $ <$value\_b$> $ ] , group:$ <$no$> $ \par }
\par
\vspace{3pt}
Reinitializes the pseudo random generator. The seed passed to the 
random generator is -abs(nint(value)). If the $ <$value$> $ is omitted, 
the random generator will be passed the number of hundredth of 
seconds passed since midnight, essentially initializing the sequence 
at a unknown fairly random point. 
\par
The seed may take more than one parameter, usually the compiler 
takes 12 different seeds. 
\par
To overcome limited internal precision, a patch has been introduced 
in version 5.17.0. 
As the random number generator takes seeds in the range from 
1 to 99999999 the internal precision that calculates the value 
on the command line via the detour of a real valued number turned 
out to be insufficient. To ensure that an eight digit seed number 
is properly transfered to the seed initialization routine, split 
the number into two groups of four digit integers as in: 
12345678  =$> $ 1234, 5678, group:2 
The optional parameter "group" tells the SUITE to group these two 
numbers together to the original intended eith digit no. 
\section{matrix}
\par
For the user defined 1-D and 2-D matrices several command are 
available for the usual matrix arithmetics. These are: 
\subsection*{detmat}
{\bf detmat $ <$matrix$> $ \par }
\par
\vspace{3pt}
Calculates the determinant of a [n x n] matrix. Currently limited 
to dimensions 1 to 4. 
\subsection*{invmat}
{\bf invmat $ <$result$> $, $ <$input$> $ \par }
\par
\vspace{3pt}
Calculates the inverse matrix for $ <$input$> $ and stores the result 
in $ <$result$> $. Both matrices must be square with identical 
dimenstions 1 to 4. 
\subsection*{matmul}
{\bf matmul $ <$result$> $, $ <$a$> $ [, $ <$b$> $] \par }
\par
\vspace{3pt}
A generic name for several calculations. Mainly, of course, the 
standard matrix multiplications of user defined variables 
$ <$a$> $ with $ <$b$> $. 
Either or both of $ <$a$> $ and $ <$b$> $ may be arbitrary scalar expressions. 
The result and the input matrices may be 1-D and or 2-D 
according toi the standard rules for matrix multiplications 
\par
Thus the command essentially provides the operations: 
\par
1) Result\_matrix = Scalar 
2) Result\_matrix = Scalar * Scalar 
3) Result\_matrix = Scalar * Matrix = Matrix * Scalar 
4) Result\_matrix = Matrix 
5) Result\_matrix = Matrix * Matrix 
\par
1) and 2): Each matrix element is set to the scalar value 
    Result[i,j] = scalar 
3): Each input matrix element is multiplied by the scalar 
    and each result element corresponds to the input matrix 
    element 
    Result[i,j] = scalar * Input[i,j] 
4): The result matrix is identicla to the input matrix 
    Result[i,j] = Input[i,j] 
5): Standard matrix multiplication 
    Result[i,j] = A[i,k] * B[k,j] 
\par
For operations 3 and 4, both matrices must be of identical 
shape and dimension. 
For operation 5 the standard rule on shape and dimensions 
holds with 
    Result[i,j] = A[i,k] * B[k,j] 
\subsection*{matadd}
{\bf matadd $ <$result$> $, $ <$a$> $ [, $ <$scalar$> $], $ <$b$> $ \par }
\par
\vspace{3pt}
Adds two user supplied matrix variables. 
    Result[i,j] = A[i,j] + Scalar * B[i,j] 
\par
The three matrices have to be of identical shape and dimensions, 
The scalar is optional and defaults to +1. 
The result matrix may be the same variable as any of the 
two input matrices. 
\subsection*{mattrans}
{\bf mattrans $ <$resul$ <$, $ <$input$> $ \par }
\par
\vspace{3pt}
Calculates the transposed matrix for $ <$input$> $ and stores this 
in $ <$result$> $ 
\par
\section{set}
{\bf set $ <$command$> $,.. \par }
\par
\vspace{3pt}
This command allows to alter various program independent setting. 
Allowed values for $ <$command$> $ are: 
\par
\subsection*{prompt}
{\bf set prompt, $ \{$"on"$| $"off"$| $"redirect"$\} $,[$ \{$"on"$| $"off"$| $"file"$\} $, ["save"]] \par }
{\bf set prompt, "old" \par }
\par
\vspace{3pt}
First parameter sets the status of the PROG prompt. The default is 
"on", i.e. PROG prompts for the next command by writing "discus $> $ " 
(in case you run DISCUS ..). You can turn this prompt off. This is 
useful, if you are running a long macro and do not 
want to get all the prompts written into the output. By using this 
option you can considerably shorten the output written by PROG into a 
redirected log file. If you are using PROG on a UNIX platform, you can 
start the program with redirected input by the command: 
\par
\begin{MacVerbatim}
"prog < inputfile"
\end{MacVerbatim}
By default, PROG will write the prompt "discus $> $" into the output file, 
expecting a RETURN from the keyboard. Very long lines in the output file 
will result. To avoid this situation insert the line "set output,redirect" 
as first line in the inputfile to force discus to echo the lines from file 
inputfile. 
\par
The prompt setting "redirect" has an important side effect on macro 
treatment. With the "redirect" setting, macros are stored internally, 
once they have been read from disk, and will be reused from memory. This 
helps to reduce unnecessary I/O, especially when you have nested macros 
inside loops. For all other settings, the internal macro storage is 
cleared when you get back to the normal interactive mode. This allows 
you to run a macro, then modify the version stored on the disk and 
execute the modified/corrected version. 
\par
This second parameter  allows the user to assign where the text output 
of the program should go: "on" prints on the screen, "off" will result 
in no output and "file" will save the output to a file progname.log 
(e.g. discus.log in DISCUS). Note that the output of the commands 
'echo' and 'eval' will always appear on the screen. The last parameter 
allows on to save the current prompt and output settings. 
\par
The parameter "old" allows the user to restore the setting of the 
prompt and output. This can e.g. be used to turn the prompt off in a 
macro and then restore the original setting after the macro is executed. 
Make sure that you saveed the desired prompt by setting the last 
parameter to "save". 
\subsection*{error}
{\bf set error , $ \{$"cont" $| $ "exit" $| $ "live" $| $ "old"$\} $ [ , "save"] \par }
\par
\vspace{3pt}
Sets the error status. 
\par
\begin{MacVerbatim}
"cont"  PROG returns the normal prompt after the display of the error
        message. You can continue the input of commands.
        The execution of a macro file is stopped, the program continues
        with the regular prompt of the menu/submenu where the error occurred.
"exit"  PROG terminates after the display of the error message.
        This option is useful if you run PROG in the batch mode of your
        operating system. Instead of continuing with a faulty calculation
        PROG stops and you can immediately check the error.
"live"  PROG remains alive after an error is encountered. The variable
        "res[0]" is set to -1. The error number is written into "res[1]",
        the error type to "res[2]". Further error codes are written into
        "res[3]".
        With this error status, the program remains alive within a loop
        as well, which it does not do with the error status "cont".
        The program also continue to execute a macro!
        It is most helpful to catch errors from the 'system' command
        and to allow a flexible response.
"old"   Restore the last error status that was set and saved in a
        previous 'set error, <value>, save ' command.
\end{MacVerbatim}
\subsection*{debug}
{\bf set debug, $ \{$"on" $| $ "off"$\} $ \par }
\par
\vspace{3pt}
This command allows the user to enable various DEBUG outputs ... 
\subsection*{wait}
{\bf set wait, $ \{$"on" $| $ "off"$\} $ \par }
\par
\vspace{3pt}
This command allows the user to tailor the 'wait' comand. 
The default is 'set wait, on'. 
With 'set wait, on' the 'wait' command in a macro is active. 
With 'set wait, off' the 'wait' command in a macro will be 
ignored and the programm continues execution as if the 
'wait' command were absent. 
\section{show}
{\bf show $ \{$"res" $| $ "variables"$\} $ \par }
\par
\vspace{3pt}
The show command displays settings onto your screen. The individual 
programs discus, kuplot, diffev, mixscat all have specific parameters 
to the show command as well, see the help at the main program level 
for details. 
\par
\begin{MacVerbatim}
"res"
\end{MacVerbatim}
Many commands produce results that are stored in the result variable 
res[$ <$i$> $]. Thise are displayed via "show res". 
The entry res[0] gives the number of entries in the result variable. 
\par
\begin{MacVerbatim}
"variables"
\end{MacVerbatim}
Lists the variables that have been defined, their type and their 
current values. The command is identical to the "variable show" 
command. 
\section{sleep}
{\bf sleep $ <$seconds$> $ \par }
\par
\vspace{3pt}
This command causes the program to sleep for $ <$seconds$> $ seconds 
\section{socket}
{\bf socket "open",$ <$host$> $,$ <$port$> $ \par }
{\bf socket "close" \par }
{\bf socket "exit" \par }
{\bf socket "send",$ <$string$> $ \par }
{\bf socket $ <$string$> $ \par }
{\bf socket "transfer",$ <$slave\_var$> $,$ <$expression$> $ \par }
{\bf socket "transfer",$ <$slave\_var$> $,$ <$character expression$> $,$ <$local\_var$> $ \par }
\par
\vspace{3pt}
These commands connect to a program that has been started with the 
"-remote" option, sees ==$> $ "Options" for further help. 
The commands will be send to the slave program where they will be 
executed as typed. 
\par
\subsection*{open}
{\bf socket "open",$ <$host$> $,$ <$port$> $ \par }
\par
\vspace{3pt}
Opens the connection to the program running on host $ <$host$> $ and 
listening on port $ <$port$> $. The server program  must have been 
started beforehand with the "-remote" option 
\subsection*{close}
{\bf socket close \par }
\par
\vspace{3pt}
Temporarily closes the connection to the slave program, which keeps 
running. You can open to the same program with a new socket open,$ <$pname$> $. 
\subsection*{exit}
{\bf socket exit \par }
\par
\vspace{3pt}
Terminates the slave program and closes the connection. To communicate 
with the slave program again, you must first start this with the 
"-remote" option and then open the connection with 
socket "open",$ <$pname$> $. 
\subsection*{send}
{\bf socket send,$ <$string$> $ \par }
{\bf socket $ <$string$> $ \par }
\par
\vspace{3pt}
The string is send to the slave program and executed as typed. 
Both forms are equivalent. 
\subsection*{transfer}
{\bf socket transfer,$ <$slave\_var$> $,$ <$expression$> $ \par }
{\bf socket transfer,$ <$slave\_var$> $,$ <$character expression$> $,$ <$local\_var$> $ \par }
\par
\vspace{3pt}
This command transverse the value of $ <$expression$> $ to the slave 
variable $ <$slave\_var$> $. You must define this slave variable prior 
to a transfer. 
\subsection*{Example}
\par
\begin{MacVerbatim}
system /usr/local/bin/kuplot -remote   ! starts kuplot slave
i[0] = 4.0                             ! set local variable
socket open,localhost,3331             ! open connection
socket func r[0]**2,-2,2,0.1           ! define a function to plot
socket transfer,i[1],i[0]              ! transfer local variable
socket tit1 "%d",i[1]                  ! set plot title
socket plot                            ! display plot
socket mark 1,1                        ! change marker interval
socket plot                            ! plot again
socket send, mark 0.5,0.5              ! change marker interval
socket send, plot                      ! plot again
socket exit                            ! terminate kuplot, exit
\end{MacVerbatim}
\section{stop}
{\bf stop \par }
\par
\vspace{3pt}
This command is active only while reading from a macro file or in 
interactive mode inside a block structure (do-loops and/or if's). 
\par
The current macro file is interrupted and you can type commands as in the 
normal input mode. You can use the whole range of PROG commands, 
including the '@' macro command. The 'stop' commands provides a convenient 
mode to debug a macro by setting a break point at which you can check the 
value of variables or set new values, run an additional macro etc. 
\par
To continue execution of the macro or to continue with the normal 
PROG mode, use the ==$> $ 'continue' command. 
\par
If included in a block structure statement (do-loops and/or if's) in 
both, macro and interactive mode, the program continues reading all 
statements that belong to the block structure. During execution of the 
structure, PROG interrupts this execution if it encounters a 'stop' 
command. You can issue any PROG command except further do or if commands. 
\par
To continue execution of the structure or to continue with the normal 
PROG mode, use the ==$> $ 'continue' command. 
\section{system}
{\bf system $ <$com$> $ \par }
{\bf system "string\%dstring",$ <$integer expression$> $ \par }
{\bf system "string\%fstring",$ <$float expression$> $ \par }
\par
\vspace{3pt}
Executes the single shell command $ <$com$> $. 
If the command string is enclosed in "", you can place integer and 
real format specifiers "\%d" "\%f" which are then substituted by the 
corresponding values. 
The shell command $ <$comm$> $ may be placed in front of the double 
quotation marks. 
\par
Example 
i[0]=10 
system "ls \%d.*" 
system ls "\%d.*" 
\par
This would list all files called 10.* 
\section{wait}
{\bf wait [$ \{$"return" $| $ "input" [,$ <$prompt$> $] $\} $] \par }
\par
\vspace{3pt}
This command waits for user input. 
Without a parameter or with "return", the program waits for a 
simple $ <$RETURN$> $. 
If the first parameter is "input", the program expects the user to enter 
one or more real numbers or expressions. The optional $ <$prompt$> $ can be 
used to ask the user to input the expressions. This is especially 
helpful if the prompt has been turned of by ==$> $ set prompt,off. 
The number of expressions entered by the user is stored in the variable 
res[0] and the results of the expressions in res[i]. 
\par
This command allows to write interactive macros, demo macros 
and tutorials. 
\par
With the command 
{\bf set wait, $ \{$"on" $| $ "off"$\} $ \par }
\vspace{3pt}
you can toggle the active state of the wait command on off. 
\par
The default is 'set wait, on'. 
With 'set wait, on' the 'wait' command in a macro is active. 
With 'set wait, off' the 'wait' command in a macro will be 
ignored and the programm continues execution as if the 
'wait' command were absent. 
\section{variable}
\begin{MacVerbatim}
variable {"integer"|"real"},<name> [,<initial_value>] [,dim:[d1,d2]]
variable {"character"},<name>
variable show
variable reset
variable delete {,"all"| <name>..]
\end{MacVerbatim}
The programs that are part of the DIFFUSE suite offer predefined 
variables i[*] and r[*]. These are an integer and a real 
array, respectively, into whose element you may store appropriate 
values. 
In order to enhance readability of a macro, you can define your 
own variable names by the use of this command. The variable may 
either be an integer or a real variable. There is no predefined 
syntax for the variable names. Optionally you can initialize the 
variable to $ <$initial\_value$> $, default is zero. These user defined 
variables may be used just as the system integer and real 
variables i[*] and r[*]. 
Character variables may be used to hold a string of text. 
\par
The variable names may only consist of alphanumerical characters 
including the underscore "\_". 
"Real" and "Integer" variables my optionally be declared as 
one or two dimensional arrays. Specify the dimension as: 
dim:[12]  for a 1-D array of length 12 
dim:[3,3] for a 2-D array of length 3x3 
Array indices start at 1. 
Presently character variables are single value variables. 
\par
Several system variable exist that are read only. Several of 
these refer to the refinement section DIFFEV. These variables 
all start with "REF\_". See the DIFFEV on-line help and manual 
for further details. 
\par
If the first command parameter is "show" the program displays a 
list of user defined variables and their current values. 
Refer to the help entry "expressions" for further help. 
\par
Both, the "reset" and the "delete, all" parameters specify that 
the variable list is to be cleared of all user defeined variables. 
Only the system variables remain. 
\par
Alternatively, the "delete, $ <$name$> $" parameters allow you to delete 
an individual variable. 
\par
Examples: 
\begin{MacVerbatim}
variable  int,alpha,90
variable  int,beta
variable  real,diff
beta = 94
diff = alpha - beta
eval diff
variable  character,string
variable  character,line
string = "abcdefg"
line   = "%3c",string(2:4)
var show
\end{MacVerbatim}
Variable names that are part of intrinsic functions, keywords like 
"do", "elseif", "eq", and program specific variables like "r" and "i" 
are not allowed. Thus a variable called "a" is illegal, since it 
is part of the intrinsic function "asin". 
\par
Internally the program sorts the variable names by length and in 
inverse alphabetical order. This sorting has no serious consequence 
for the user other than finding the variable in the printed list 
when using the 'variable show' command. 
\par
A few predefined variables exist, their names are capitalized: 
PI  3.1415... 
REF\_GENERATION  Current generation number as set by DIFFEV 
REF\_MEMBER      Current population size   as set by DIFFEV 
REF\_CHILDREN    Current child population size as set by DIFFEV 
REF\_DIMENSION   Current Number of parameters a set by DIFFEV 
                If the value is changed, you can store more 
                values in ref\_para[], but this does NOT change 
                the actual dimension pop\_dimx that DIFFEV uses. 
PROGRAM         Tells you in which section you are possible 
                values are SUITE=0, DISCUS=1, DIFFEV=2, KUPLOT=3 
STATE           Tells you whether this is the TOP=0 level, a 
                SECTION=1 or a BRANCH=2. 
MPI             Was the program started with MPI ? 
                MPI\_ON=1, MPI\_OFF=0 
MPI\_FIRST       Is this the first call to DIFFEVs ==$> $ 'run\_mpi' 
                command with the current GENERATION? FALSE=0 TRUE=1 
\section{errors}
\par
The program has been written such that it should handle almost 
any typing error when giving commands and hopefully all errors 
that result from calculation with erroneous data. When an error 
is found an error message is displayed that should get you back 
on track. See the manual for a complete list of error messages. 
In this part we refer to the program you are using as DISCUS for 
convenience. 
\par
The error messages concerning the use of the command language 
are grouped in the following categories: 
\par
\begin{MacVerbatim}
COMM   Command language errors
FORT   Fortran interpreter errors
I/O    Errors regarding input/output
MACR   Errors related to macros
MATH   General mathematical errors
\end{MacVerbatim}
Each error message is displayed together with the corresponding 
category $ <$cccc$> $ and the error number $ <$numb$> $ in the form: 
\par
\begin{MacVerbatim}
****CCCC****message                    **** numb ****
\end{MacVerbatim}
In the default mode DISCUS returns the standard prompt and you can 
continue the execution from this point. You can set the error status 
to "exit" by the ==$> $'set' command. In this case DISCUS terminates 
if an error is detected. This option is useful to terminate a faulty 
sequence of commands when running DISCUS in the batch mode of your 
operating system. 
\par
\subsection*{comm}
\par
Command language errors 
These messages describe illegal usage of the command language, such as 
unknown commands, improper numbers of parameters. 
\par
\subsubsection{Error -1: DISCUS directory not defined}
\par
The environment variable DISCUS\_DIR was not defined. Check the chapter 
on installation for your platform for the appropriate definition. 
\subsubsection{Error -2: Command parameter has zero length}
\par
On the command line you probably have a typing error like two 
comma following each other without significant values in between, 
or the first non blank character after the command is a comma. 
\subsubsection{Error -3: Could not allocate arrays}
\par
The program has to allocate arrays, but received a error message. 
Does your computer have enough available memory space? 
\subsubsection{Error -5: Error in operating system command}
\par
The operating system/shell returned an error message. Check the 
appropriate system manuals for details. 
\subsubsection{Error -6: Missing or wrong parameters for command}
\par
Either the command needs more parameters than were provided, or the 
parameters are incorrect. Check the number and type of parameters. Is 
the sequence of numerical and character parameters correct? 
\subsubsection{Error -8: Unknown command}
\par
The command interpreter read an unknown command. Check the spelling 
of the command or check, whether this command is allowed at the current 
sublevel. 
\subsubsection{Error -11: Error in subroutine}
\par
More or less a system error message, ignore this message. 
\subsubsection{Error -17: Too many parameters}
\par
More parameters have been provided than are required by the command. 
Check the number, and type of parameters supplied, or the occurrence 
of additional ','. 
\subsection*{fort}
\par
Fortran interpreter errors 
These messages describe erroneous mathematical calculations and 
improper usage of control structures (do,if, ...). 
\par
\subsubsection{Error -1: Nonnumerical Parameters in expression}
\par
The interpreter found a nonnumerical string where a number is expected. 
If an intrinsic function or a variable was intended, check for spelling 
or missing parentheses. 
\subsubsection{Error -2: Unknown Variable}
\par
The expression contains a reference to an unknown variable. Check the 
spelling of the variable. Chapter 3.7.1 of the manual and the help 
entry "variables" contains a list of allowed variables. 
Check whether the variable is a read-only variable and was used on the 
left side of an expression. Some of the variables associated with 
microdomains are read-only depending of the circumstances! 
\subsubsection{Error -3: Unknown intrinsic function}
\par
The expression contains a reference to an unknown intrinsic function. 
Check the spelling of the function. Chapter 3.7.4 of the general part 
in the manual and the help entry "functions' contain a complete list 
of the allowed intrinsic functions. 
\subsubsection{Error -4: Division by zero'}
\par
An attempt was made to divide by zero. Check the value of the argument 
and correct the algorithm that calculates the argument. 
\subsubsection{Error -5: Square root of negative number}
\par
An attempt was made to calculate the square root of a negative argument. 
Check the value of the argument and correct the algorithm that calculates 
the argument. 
\subsubsection{Error -6: Missing or wrong Parameters for command}
\par
Either the function or variable referenced needs more parameters than 
were provided, or the parameters are incorrect. Check the number and 
type of parameters. Is the sequence of numerical and character parameters 
correct? 
\subsubsection{Error -7: Argument for asin,acos greater 1}
\par
An attempt was made to calculate asin or acos with an argument greater 
than 1. Check the value of the argument and correct the algorithm 
that calculates the argument. 
\subsubsection{Error -8: Index outside array limits}
\par
The index supplied for the variable is outside the limits of this 
variable. Check the general part for the dimensions of the variables. 
\subsubsection{Error -9: Number of brackets is not matching}
\par
The number of opening and closing brackets "[" and "]" does not match 
or is illegally nested with parentheses "(", ")" or other operators. 
Check the string used in the expression and correct it following the 
FORTRAN rules. 
\subsubsection{Error -10: Index for array element is missing}
\par
You have used a string like "i[]", where the opening and closing 
brackets do not contain any expression. 
Check the string used in the expression and correct it following the 
FORTRAN rules. 
\subsubsection{Error -11: Number of parentheses is not matching}
\par
The number of opening and closing parentheses "(" and ")" does not match 
or is illegally nested with brackets "[", "]" or other operators. 
Check the string used in the expression and correct it following the 
FORTRAN rules. 
\subsubsection{Error -12: Expression between () is missing}
\par
You have used a string like "()", where the opening and closing 
parentheses "(" and ")" do not contain any expression. 
Check the string used in the expression and correct it following the 
FORTRAN rules. 
\subsubsection{Error -13: Wrong number of indices for array}
\par
The number of indices given for the entered parameter is wrong. 
Check the help entry 'variables' for the proper number of indices. 
\subsubsection{Error -14: Index of DO-loop counter is missing}
\par
Here the index for the loop counter of a do-loop is missing. Check 
the online help for the correct syntax of such loops. 
\subsubsection{Error -15: Too many commands}
\par
The program stores all commands within a control block in an array. 
The maximum number of commands that can be stored in this array is 
given by the parameter MAXCOM in file "doloop.inc". The macro or run 
used more commands than currently allowed by this parameter. 
Rewrite the macro or list of commands such that less commands are 
sufficient, or change the value of the parameter and recompile the 
program. 
\subsubsection{Error -16: Too deeply leveled (do,if) construction}
\par
The program stores all commands within a control block in an array. 
The maximum number of levels for this array is given by the parameter 
MAXLEV in file "doloop.inc". The macro or run used more levels than 
currently allowed by this parameter. 
Rewrite the macro or list of commands such that less levels are 
sufficient, or change the value of the parameter and recompile the 
program. 
\subsubsection{Error -18: Unresolvable condition}
\par
An error occurred while trying to calculate the value of an arithmetic 
or logical expression. Check that there is no illegal operation /(division 
by zero .../ no typing errors, all parentheses are properly matched. 
\subsubsection{Error -19: Illegal nesting of control commands}
\par
Do  loops and/or if constructions have been nested with overlapping 
segments, missing enddo or endif statements or similar causes. Check 
for spelling errors on the control statements, and that each control 
statement is properly terminated by a corresponding enddo or endif 
statement that is not enclosed within another control block. 
\subsubsection{Error -20: Illegal argument for ln(x) function}
\par
The argument for the ln must be positive, larger than zero. Check the 
value of the argument or the value of the expression that serves as 
argument 
\subsubsection{Error -21: Missing ' while comparing stings}
\par
An expression of the form ('string' .eq. 'line') was used, where 
one of the quotation marks has been omitted. Check the respective 
line. 
\subsubsection{Error -22: Maximum number of real variables defined}
\par
DISCUS can define a fixed number of user variable names. The maximum 
number allowed for your installation id displayed by the command 
variable show 
If you would like more user definable variable names, change 
the value of the parameter VAR\_REAL\_MAX in "config.inc" 
\subsubsection{Error -23: Maximum number of int. variables defined}
\par
DISCUS can define a fixed number of user variable names. The maximum 
number allowed for your installation id displayed by the command 
variable show 
If you would like more user definable variable names, change 
the value of the parameter VAR\_INTE\_MAX in "config.inc" 
\subsubsection{Error -24: Variable is not defined}
\par
You tried to use a name within an expression that was not recognized 
as a user defined variable name. Check the spelling of the line. 
Was an intrinsic function to be used, or was the variable not 
defined? See the ==$> $ 'variable' entry in the help menu regarding 
the definition of variables. 
You will also get this error message if you tried to define a 
variable using the command: 
variable real,dummy=3 
The equal sign "=" may not be used as part of a variable name. If 
you intend to provide an initializing value, use the command as: 
variable real,dummy,3 
\subsubsection{Error -25: Variable name contains illegal characters}
\par
You tried to define a variable name that contains characters other 
than letters, numbers or the underscore "\_". 
The variable names are restricted to alphanumerical characters and 
the underscore "\_". 
\subsubsection{Error -26: Variable name contains illegal characters}
\par
Variable names may consist only of letters (lower and upper case), 
numbers and the underscore "\_". Check the spelling of the variable 
you tried to define with respect to these rules. 
\subsubsection{Error -27: Function with wrong number of arguments}
\par
You called an intrinsic function with the wrong number of arguments. 
Check the listing of intrinsic functions for the valid number of 
arguments and the compare to the input line you had typed. 
\subsubsection{Error -28: Too deeply leveled break command}
\par
Illegal use of the break command. The parameter on the break command 
signals how many block structure levels are to be exited. Check the 
value of this parameter with regard to the nesting of do-loops and 
if-blocks. 
\subsubsection{Error -29: Character substring out of bounds',        \& !-29  ! fortran}
\par
In a statement like 
variable character, line 
line = 'abcde' 
echo "\%c",line(1,5) 
The first index is  less than one, or the second index is larger than 
the number of characters in the strin, or the second index is less 
than the first. 
\subsubsection{Error -30: Right quotation mark missing in format'}
\par
A statement like 
echo " text " 
is missing the right quotation mark. 
\subsubsection{Error -31: Incomplete (do,if) statement}
\par
Some part of a ==$> $ 'do' or ==$> $ 'if' statement is missing. 
Check the line for missing part or typing errors. 
\subsubsection{Error -32: Variable name is already defined}
\par
The variable that you want to define is already in use as another 
data type. 
\subsubsection{Error -33: Variable in use; cannot initialize value}
\par
A variable name can be redifined as identical data type, in order 
to be able to use a macro with a variable definition inside a loop. 
You may, however, not provide an initialisation value, as this would 
override the current value. 
\subsubsection{Error -34: String has length zero',                   \& !-34  ! fortran}
\par
A statement like 
echo ""   or 
line = '' 
occured in which the single or doluble quotation marks enclose a 
zero length string. 
\subsection*{i/o}
\par
Errors related to input / output 
An error occurred while attempting to read/write from a file 
\par
\subsubsection{Error -1: File does not exist}
\par
DISCUS could not find the file. Check the spelling and the path. 
\subsubsection{Error -2: Error opening file}
\par
DISCUS could not open a file. The file might be in use by another process. 
\subsubsection{Error -3: Error reading file}
\par
An error occurred while  DISCUS was reading a file. Check whether the 
contents of the file is correct. 
\subsubsection{Error -4: File already exists}
\par
An attempt was made to overwrite an existing file. Rename or delete 
the file in question. 
\subsubsection{Error -5: No such entry in online help}
\par
You have tried to obtain help for a string that does not have a matching 
entry in the help file. 
\par
Check the spelling of the string. Are you at the right sublevel? 
Use the '?' command to get a listing of available help entries. 
\subsubsection{Error -6: Unexpected end of file}
\par
DISCUS has encountered the end of a file, but is still expecting data. 
Check the file(s) involved, to see whether the data are complete or 
whether erroneous data are present. 
\subsubsection{Error -7: Learning sequence already in progress}
\par
You have tried to start a learning sequence by ==$> $'learn' without 
closing the active learning sequence. Close the current learning 
sequence by ==$> $ 'lend' before starting to record a new macro. 
\subsubsection{Error -8: Nothing learned - no macro written}
\par
You did not type any commands since the ==$> $'learn' command. No commands 
are written to the macro file. 
You need to give at least one command before closing a learn sequence. 
\subsubsection{Error -9: Error reading user input}
\par
An error occurred while reading the last input. 
Does the string contain any characters where a number is expected, or 
any control or escape sequences. 
\subsubsection{Error -10: IO stream already open}
\par
The command 'fopen' was issued while there was already a file open. 
Close the currently open file with 'fclose'. 
\subsubsection{Error -11: No IO stream open to close}
\par
The command 'fclose' was issued, but there is no open file. 
\subsubsection{Error -12: Error writing to file}
\par
An error occurred when reading a file with 'fget'. Check the file 
for nonnumerical values and check that the number of columns is 
equal or larger than the number of arguments of 'fget'. 
\par
\subsubsection{Error -13: I/O stream number outside valid range}
\par
The I/O stream number must be larger than 0 and less than the value 
defined in macro.inc, which usually is 10. 
\par
\subsubsection{Error -14: Filename has zero length}
\par
You tried to open a file with ==$> $ 'fopen', whose file name is of 
length zero. 
Check the statement for the missing filename, or an additional comma. 
\subsubsection{Error -15: No socket connected}
\par
Apparently you tried to use a ==$> $ 'socket' command prior to opening 
a connection to the remote computer. 
Use a 'socket open' command first. 
\subsubsection{Error -16: Could not resolve hostname for socket}
\par
The hostname to which you want to connect could not be resolved into 
an IP address. 
Check the host name for typing errors and the Internet access of your 
computer. 
\subsubsection{Error -17: Could not grab socket}
\par
Internal socket debug message. 
\subsubsection{Error -18: Could not open socket connection}
\par
Internal socket debug message. 
\subsubsection{Error -19: Problem sending to socket}
\par
Internal socket debug message. 
\subsubsection{Error -20: Problem receiving from socket}
\par
Internal socket debug message. 
\subsubsection{Error -21: Received null string from socket receive}
\par
The remote computer send back an answer of zero length. Apparently 
the connection was terminated prematurely. 
\par
Try to connect again. 
\subsubsection{Error -22: Socket accept problem}
\par
Internal socket debug message. 
\subsubsection{Error -23: Scocket: Rejected connection}
\par
Internal socket debug message. 
\subsubsection{Error -24: Socket bind problem}
\par
Internal socket debug message. 
\subsubsection{Error -25: Socket listen problem}
\par
Internal socket debug message. 
\subsubsection{Error -26: Second parameter must be $> $= first Param.}
\par
You tried to read a substring with a line like 
echo "\%c",line(1:5) 
but the second parameter , here a "5" was less than the first, here a "1". 
The second parameter must be equal to or larger than the first in order 
to specify a valid substring. 
\subsection*{macro}
\par
Errors related to macro 
These messages describe situations that result from missing macrofiles, 
missing macro parameters ... 
\par
\subsubsection{Error -1: Too many macro parameters given}
\par
The number of parameters given on the macro command line is higher 
than allowed in your installation. The maximum number of parameters 
allowed is defined by the parameter MAC\_MAX\_PARA in the file 
macro.inc. 
Check the macro command line for any additional "," or rewrite the 
macro to use less parameters. If necessary adjust the value of the 
parameter MAC\_MAX\_PARA and recompile the program. 
\subsubsection{Error -12: Macro not found}
\par
The file given on the @$ <$name$> $ command does not exist. Check the 
spelling of $ <$name$> $ and the path. 
\subsubsection{Error -13: Macro filename is missing on the command line}
\par
The command '@' to execute a macro was called without any macro 
file name. The file name must start immediately after the "@". 
Check the '@' command for completeness and blanks after the "@". 
\subsubsection{Error -35: Too deeply leveled macros}
\par
The maximum level at which macros may be nested is defined in the 
file macro.inc in the parameter MAC\_MAX\_LEVEL. Check the nesting of 
macro file for the level of nesting or possible recursive nesting 
without proper termination. Rewrite the macros to use less nesting, 
or change the value of the parameter and recompile the program. 
\subsubsection{Error -36: Unexpected EOF in macro file}
\par
When DISCUS finds a '@' command inside a macro, it stores the current 
macro name, the line number inside the current macro and closes the 
current macro file. After completion of the new macro, the previous 
macro is read again up to the position stored. The error message 
is displayed when an end of file is found before the position is 
reached. Check whether the macro file was damaged, or accidentally 
deleted during execution of the nested macro. 
\subsubsection{Error -41: Not enough macro parameters given}
\par
DISCUS read a parameter number inside a macro file that is higher 
than the number of parameters given on the command line of the macro. 
Check the parameters inside the macro for correct numbering and 
spelling. Check the number of parameters supplied on the command and 
check whether any "," is missing between parameters. 
